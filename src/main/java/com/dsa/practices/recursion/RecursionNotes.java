package com.dsa.practices.recursion;

public class RecursionNotes {
    /*

    Definition: A function that calls itself.
    Recursion is a fundamental programming concept where a function calls itself to solve a smaller
    problem of the same problem until it reaches a base condition.


    The recursion Spell:
    #1. Identify the smaller Problem -> Let recursion solved.
    #2. Self word -> Do your work
    #3. Identify the base case -> End of the function (Avoid the infinite loop)


    Key Takeaways
    #1. Recursive calls go deeper until the base case is hit.
    #2. The call stack keeps track of all function calls.
    #3. Once the base case is met, the stack unwinds, returning values in reverse order.
    #4. If recursion is too deep, it can lead to a StackOverflowError.


    Characteristics of Recursion
    #1. Base Case: A stopping condition to prevent infinite recursion.
    #2. Recursive Case: A function calls itself with modified parameters.
    #3. Stack Usage: Each recursive call is stored in the call stack.
    #4. Divide and Conquer Approach: Problems are broken down into smaller subproblems.
    #5. Overlapping Subproblems: Some recursive problems can be optimized using memoization.


    Use Cases of Recursion
    #1. Mathematical Problems: Factorial, Fibonacci, GCD (Greatest Common Divisor).
    #2. Tree and Graph Traversal: Depth-First Search (DFS), Binary Tree Traversal (Preorder, Inorder, Postorder).
    #3. Sorting Algorithms: QuickSort, MergeSort.
    #4. Backtracking: Sudoku Solver, N-Queens Problem, Word Search.
    #5. Dynamic Programming: Solving problems like Knapsack, Coin Change with memoization.
    #6. File System Navigation: Recursively listing directories and files.


    */
}
